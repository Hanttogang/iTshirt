# 1-1. 함수와 일급 객체

## 일급 객체

일급 객체란 **함수를 변수와 같이 다루는** 언어에 있는 개념입니다.

자바스크립트의 함수는 기본적으로 객체입니다.

**일급 객체의 특성**

- 상수 또는 변수에 **할당**될 수 있음
- 다른 함수에 **인자로 전달**될 수 있음
- 다른 함수의 결과값으로서 **반환**될 수 있음

### 1. 함수의 할당

자바스크립트에서는 함수를 변수에 할당할 수 있습니다. 이는 함수를 다른 값처럼 취급할 수 있다는 의미입니다.

**1. 함수가 변수에 할당될 수 있음**

```jsx
// 함수를 변수에 할당
const greet = function(name) {
    return "안녕하세요, " + name + "님!";
};

// 할당된 함수를 호출
console.log(greet("홍길동")); // "안녕하세요, 홍길동님!" 출력
```

**2. 함수가 다른 함수에 할당될 수 있음**

함수는 다른 함수의 변수로도 할당될 수 있습니다. 이 경우, 하나의 함수가 다른 함수를 가리키게 됩니다.

```jsx
function greet(name) {
    return "안녕하세요, " + name + "님!";
}

// greet 함수를 greetAgain 변수에 할당
const greetAgain = greet;

console.log(greetAgain("이순신")); // "안녕하세요, 이순신님!" 출력
```

**3. 함수가 객체의 속성으로 할당될 수 있음**

자바스크립트에서 함수는 객체의 프로퍼티(속성 값)으로 할당될 수 있습니다.

```jsx
const person = {
    age: 25,
    greet: function(name) {
        return "안녕하세요, " + name + "님!";
    }
};

console.log(person.greet("홍길동")); // "안녕하세요, 홍길동님!" 출력
```

- 객체에 다른 프로퍼티(속성 값)를 포함할 때 알아두면 좋은 방법이 있습니다.
객체의 다른 프로퍼티에 접근할 때, `this`를 사용합니다. 이 때 `this`는 속해있는 객체를 나타냅니다.

```jsx
const person = {
    name: "이순신",
    position: "장군"
    greet: function() {
        return "안녕하세요, " + this.name + " " + this.position + "님!";
    }
};

console.log(person.greet()); // "안녕하세요, 이순신 장군님!" 출력
```

**4. 함수가 배열의 요소로 할당될 수 있음**

함수는 배열의 요소로도 할당될 수 있습니다. 배열에 저장된 함수를 배열의 인덱스로 접근하여 호출할 수 있습니다.

```jsx
const functions = [
    function(name) { return "안녕하세요, " + name + "님!"; },
    function(name) { return "반갑습니다, " + name + "님!"; }
];

// 배열의 첫 번째 함수를 호출
console.log(functions[0]("홍길동")); // "안녕하세요, 홍길동님!" 출력

// 배열의 두 번째 함수를 호출
console.log(functions[1]("이순신")); // "반갑습니다, 이순신님!" 출력
```

### 요약

- **변수에 할당**: 함수는 변수에 할당될 수 있습니다. 이는 함수를 값처럼 다룰 수 있다는 것을 의미합니다.
- **함수에 할당**: 함수는 다른 함수에 할당될 수 있으며, 이를 통해 같은 함수를 여러 변수에서 참조할 수 있습니다.
- **객체의 속성으로 할당**: 함수는 객체의 속성으로 할당될 수 있습니다.
- **배열의 요소로 할당**: 함수는 배열의 요소로 할당될 수 있으며, 배열의 인덱스를 통해 함수를 호출할 수 있습니다.

### 2. 함수가 다른 함수의 인자로 전달될 수 있음

함수는 다른 함수의 인자로 전달될 수 있습니다. 이를 통해 **콜백 함수(callback function)**나 **고차 함수(high-order function)**를 구현할 수 있습니다.

전달받는 함수: **고차함수(high-order function)**

전달되는 함수: **콜백함수(callback function)**

```jsx
// 인자로 전달될 함수
function greet(name) {
    return "안녕하세요, " + name + "님!";
}

// 함수를 인자로 받는 함수
function processUserInput(callback) {
    const name = "홍길동";
    console.log(callback(name));
}

// 함수 `greet`를 인자로 전달
processUserInput(greet); // "안녕하세요, 홍길동님!" 출력
```

위 예제에서의 고차함수와 콜백함수
**고차함수(high-order function)**: processUserInput
**콜백함수(callback function)**: greet

고차함수에 콜백함수를 전달하는 테스트 예제

```jsx
// calculate
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

function multiply(a, b) {
    return a * b;
}

// evaluate
function isOdd(number) {
    return !!(number % 2);
}

function isPositive(number) {
    return number > 0;
}

function calcAndEval(calc, eval, x, y) {
    return eval(calc(x, y));
}

console.log(
    calcAndEval(add, isOdd, 3, 9),       // true: (3 + 9 = 12) is even, not odd
    calcAndEval(subtract, isPositive, 3, 9), // false: (3 - 9 = -6) is negative
    calcAndEval(multiply, isOdd, 3, 9)   // true: (3 * 9 = 27) is odd
);

```

### 3. 함수가 다른 함수의 결과값으로 반환될 수 있음

함수는 다른 함수의 반환 값으로 사용될 수 있습니다.

```jsx
// 함수를 반환하는 함수
function createGreeting(greeting) {
    return function(name) {
        return greeting + ", " + name + "님!";
    };
}

// 함수 `createGreeting`을 호출하여 함수 반환
const sayHello = createGreeting("안녕하세요");
console.log(sayHello("홍길동")); // "안녕하세요, 홍길동님!" 출력

const sayGoodbye = createGreeting("안녕히 가세요");
console.log(sayGoodbye("홍길동")); // "안녕히 가세요, 홍길동님!" 출력
```

```jsx
function getIntroFunc(name, formal) {
    return formal
        ? function () {
            console.log(`안녕하십니까, ${name}입니다.`);
        }
        : function () {
            console.log(`안녕하세요~ ${name}라고 해요~`);
        };
}

const hong = getIntroFunc('홍길동', true);
const jeon = getIntroFunc('전우치', false);

hong(); // "안녕하십니까, 홍길동입니다." 출력
jeon(); // "안녕하세요~ 전우치라고 해요~" 출력
```

### 요약

- **인자로 전달**: 함수는 다른 함수의 인자로 전달될 수 있습니다. 이를 통해 함수를 값처럼 전달하여 콜백 함수 등을 구현할 수 있습니다.
- **결과값으로 반환**: 함수는 다른 함수의 반환 값으로 사용될 수 있습니다. 이를 통해 함수가 동적으로 생성됩니다.
